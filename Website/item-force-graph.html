---
<!--: -->
---
<!DOCTYPE html>
<html>

<head>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://gitcdn.xyz/repo/MasterMaps/d3-slider/master/d3.slider.js"></script>
    <link rel='stylesheet' href="https://gitcdn.xyz/repo/MasterMaps/d3-slider/master/d3.slider.css">
    <link rel='stylesheet' type='text/css' href='/css/force.css'>
</head>

<body>
    <script>
    function createForce() {
        var self = this;
        self.addNode = function(version, id, size) {
            nodes.push({
                version: version,
                id: id,
                size: size,
                focus: true,
                visible: true,
            });
            return self;
        };

        self.editNode = function(version, id, size) {
            findNode(version, id).size = size;
            return self;
        }

        self.removeNode = function(version, id) {
            var i = 0;
            var n = findNode(version, id);
            while (i < links.length) {
                if ((links[i]['source'] == n) || (links[i]['target'] == n)) {
                    links.splice(i, 1);
                } else i++;
            }
            nodes.splice(findNodeIndex(version, id), 1);
            return self;
        };

        self.addLink = function(version, source, target, strength) {
            links.push({
                version: version,
                "source": findNode(version, source),
                "target": findNode(version, target),
                "value": strength,
                focus: true,
                visible: true
            });
            return self;
        };

        self.editLink = function(source, target, strength) {
            findLink(source, target).value = strength;
            return self;
        }

        self.appendTo = function(parent) {
            parent.appendChild(svg[0][0]);
            return self;
        }

        self.version = function(v) {
            if (typeof arguments[0] === 'undefined') {
                return versionValue;
            }
            versionValue = v;
            return self;
        }

        self.linkMinimum = function(min) {
            if (typeof arguments[0] === 'undefined') {
                return linkMinimumValue;
            }
            linkMinimumValue = min;
            return self;
        }

        var refreshVisible = function() {
            // Links
            for (var linkNum = 0; linkNum < links.length; linkNum++) {
                var l = links[linkNum];
                if (l.version !== versionValue) {
                    l.visible = false;
                } else if (l.value < linkMinimumValue) {
                    l.visible = false;
                } else if (l.focus === false) {
                    l.visible = false;
                } else {
                    l.visible = true;
                }
            }
            // Nodes
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                if (n.version !== versionValue) {
                    n.visible = false;
                } else if (n.focus === false) {
                    n.visible = false;
                } else if (!findNodeLinks(n).reduce(function(prev, curr) {
                        return prev || curr.visible;
                    }, false)) {
                    n.visible = false;
                } else {
                    n.visible = true;
                }
            }
        }

        var findNode = function(version, id) {
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].id === id && nodes[i].version === version) {
                    return nodes[i];
                }
            };
        };

        var findNodeIndex = function(version, id) {
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].id == id && nodes[i].version === version) {
                    return i;
                }
            };
        };

        var findLink = function(source, target) {
            for (var i = 0; i < links.length; i++) {
                if (links[i].source.id == source && links[i].target.id == target) {
                    return links[i]
                } else if (links[i].source.id == target && links[i].target.id == source) {
                    return links[i]
                }
            }
            return null;
        }

        var findNodeLinks = function(source) {
            var retLinks = [];
            for (var i = 0; i < links.length; i++) {
                if (links[i].source == source || links[i].target == source) {
                    retLinks.push(links[i]);
                }
            }
            return retLinks;
        }

        // set up the D3 visualisation in the specified element
        var w = $('body').width(),
            h = $('body').height();

        var color = d3.scale.category10();

        var svg = d3.select(document.createElementNS("http://www.w3.org/2000/svg", "svg"))
            .attr("width", '100%')
            .attr("height", '100%');
        var vis = svg
            .append('svg:g');

        var force = d3.layout.force();

        var nodes = force.nodes(),
            links = force.links();

        var focused = false;
        var versionValue;
        var linkMinimumValue;

        self.update = function() {
            var linkSizes = links.map(function(l) {
                return l.value;
            });
            var smallestLink = d3.min(linkSizes);
            var largestLink = d3.max(linkSizes);
            var linkStrengthScale = d3.scale.linear()
                .domain([0, largestLink])
                .range([0, 1]);
            var strokeScale = d3.scale.pow()
                .domain([smallestLink, largestLink])
                .range([1, 10]);
            var linkDistanceScale = d3.scale.pow()
                .domain([smallestLink, largestLink])
                .range([300, 70]);
            var nodeSizeScale = d3.scale.pow()
                .domain([0, 1])
                .range([10, 50]);


            refreshVisible();

            var link = vis.selectAll("line")
                .data(links, function(d) {
                    return d.source.version + ":" + d.source.id + "-" + d.target.version + ":" + d.target.id;
                });

            link.enter().append("line")
                .attr("id", function(d) {
                    return d.source.id + "-" + d.target.id;
                })
                .classed("link", true)
                .attr('stroke-width', 0);
            link
                .transition()
                .attr('visibility', function(d) {
                    return d.visible ? 'visible' : 'hidden';
                })
                .attr("stroke-width", function(d) {
                    return d.visible ? strokeScale(d.value) : 0;
                });
            link.exit()
                .transition()
                .attr('stroke-width', 0)
                .remove();

            var node = vis.selectAll("g.node")
                .data(nodes, function(d) {
                    return d.version + ":" + d.id;
                });
            node.exit()
                .transition()
                .remove();
            var nodeEnter = node.enter()
                .append("g")
                .classed("node", true)
                .classed('sendToTop', true)
                .call(force.drag)
                .on('dblclick', function(d) {
                    focused = !focused;
                    if (!focused) {
                        for (var i = 0; i < nodes.length; i++) {
                            nodes[i].focus = true;
                        }
                        for (var linkNum = 0; linkNum < links.length; linkNum++) {
                            links[linkNum].focus = true;
                        }
                    } else {
                        // Focus an element
                        for (var i = 0; i < nodes.length; i++) {
                            nodes[i].focus = false;
                        }
                        for (var linkNum = 0; linkNum < links.length; linkNum++) {
                            links[linkNum].focus = false;
                        }
                        findNodeLinks(d).forEach(function(l) {
                            l.focus = true;
                            l.source.focus = true;
                            l.target.focus = true;
                        })
                    }
                    refreshVisible();
                    update();
                });
            nodeEnter.append("svg:circle")
                .attr("id", function(d) {
                    return "Node;" + d.id;
                })
                .attr('stroke', 'none')
                .attr('r', 0);
            node.select('circle')
                .attr("fill", function(d) {
                    return color(d.id);
                })
                .transition()
                .attr('visiblility', function(d) {
                    return d.visible ? 'visible' : 'hidden';
                })
                .attr("r", function(d) {
                    return d.visible ? nodeSizeScale(d.size) : 0;
                });
            node.exit().select('circle')
                .transition()
                .attr('r', 0);
            nodeEnter.append('defs')
                .append('clipPath')
                .attr('id', function(d, i) {
                    return 'circle' + i;
                })
                .append('circle')
                .attr('r', 0);
            node.select('defs>clipPath>circle')
                .transition()
                .attr("r", function(d) {
                    return d.visible ? nodeSizeScale(d.size) / 1.2 : 0;
                });
            node.exit().select('defs>clipPath>circle')
                .transition()
                .attr('r', 0);
            nodeEnter.append('image')
                .attr('clip-path', function(d, i) {
                    return 'url(#circle' + i + ')';
                })
                .attr('xlink:href', function(d) {
                    //return 'http://ddragon.leagueoflegends.com/cdn/' + d.version + '.1/img/item/' + d.id + '.png'
                });
            node.select('image')
                .attr('width', function(d) {
                    return d.visible ? 2 * nodeSizeScale(d.size) / 1.2 : 0;
                })
                .attr('height', function(d) {
                    return d.visible ? 2 * nodeSizeScale(d.size) / 1.2 : 0;
                })
                .attr('x', function() {
                    return -d3.select(this).attr('width') / 2;
                })
                .attr('y', function() {
                    return -d3.select(this).attr('height') / 2;
                });
            node.exit().select('image')
                .transition()
                .attr('width', 0)
                .attr('height', 0)
                .attr('x', 0)
                .attr('y', 0);

            // because of the way the network is created, nodes are created first, and links second,
            // so the lines were on top of the nodes, this just reorders the DOM to put the svg:g on top
            $(".sendToTop").each(function(index) {
                this.parentNode.appendChild(this);
            });

            force.on("tick", function() {
                node.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

                link.attr("x1", function(d) {
                        return d.source.x;
                    })
                    .attr("y1", function(d) {
                        return d.source.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.y;
                    });
            });

            // Restart the force layout.
            force
                .gravity(1)
                .charge(function(d) {
                    return d.visible ? -30000 : 1;
                })
                .friction(0.1)
                .linkDistance(function(d) {
                    return d.source.size + d.target.size + linkDistanceScale(findLink(d.source.id, d.target.id).value);
                })
                .linkStrength(function(d) {
                    return d.visible ? linkStrengthScale(d.value) : 0;
                })
                .size([+svg.style('width').replace('px', ''), +svg.style('height').replace('px', '')])
                .start();
            return self;
        };

        // Make it all go
        return self.version('5.14')
            .linkMinimum(0.3);
    }

    var graph = createForce()
        .appendTo(document.body);
    $(function() {
        $(window).resize(function() {
            graph.update();
        });
    });

    // Link minimum slider
    d3.select($('<div>').prependTo('body')[0])
        .style('position', 'absolute')
        .style('width', '70%')
        .style('left', '20px')
        .append('div')
        .call(d3.slider()
            .scale(d3.scale.linear().domain([0, 1]))
            .axis(d3.svg.axis())
            .snap(true)
            .value(graph.linkMinimum())
            .on('slide', function(evt, value) {
                graph
                    .linkMinimum(value)
                    .update();
            })
        )
        .style('margin-bottom', 25);

    // Version slider
    d3.select($('<div>').prependTo('body')[0])
        .style('position', 'absolute')
        .style('width', '20%')
        .style('top', '60px')
        .style('left', '20px')
        .append('div')
        .call(d3.slider()
            .scale(d3.scale.ordinal()
                .domain([5.11, 5.14])
                .rangePoints([0, 1], 0.5))
            .axis(d3.svg.axis())
            .value(graph.version())
            .on('slide', function(evt, value) {
                graph.version('' + value)
                    .update();
            })
        )
        .style('margin-bottom', 25);

    // Load data
    $.getJSON('/data/itemCross.json').then(function(data) {
        for (var i = 0; i < data.nodes.length; i++) {
            var node = data.nodes[i];
            graph.addNode(node.version, node.id, node.winRate);
        };
        for (var i = 0; i < data.links.length; i++) {
            var link = data.links[i];
            graph.addLink(link.version, link.source, link.target, link.value);
        };
        graph.update();
    });
    </script>
</body>

</html>
