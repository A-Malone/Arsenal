<!DOCTYPE html>
<html>

<head>
    <script src='/js/d3.min.js'></script>
    <script>
    d3.selection.prototype.union = function(that) {
        if (that instanceof d3.selection) {
            var newselection = d3.select(null); //ensure the correct prototype
            newselection.splice(0, 1); //empty the selection      
            [].push.apply(newselection, this); //push in this selection, without loosing the prototype 
            [].push.apply(newselection, that); //push in that selection, without loosing the prototype
            return newselection;
        } else {
            throw new Error("Can only union with another d3 selection");
        }
    };
    </script>
    <link rel='stylesheet' type='text/css' href='/css/stacked.css'>
</head>

<body>
    <script>
    var title = 'Data set';
    var data = [{
        title: "ABC",
        values: [32314, 100000]
    }, {
        title: "B",
        values: [112394, 50000]
    }, {
        title: "C",
        values: [2433, 12310]
    }];


    var createStackedComparison = function(parent) {
        var width = 640;
        var height = 480;

        var centerSpacing = 100;
        var titleHeight = 60;
        var titleMargin = 20;

        var boxWidth = 60;

        var exploded = "exploded";
        var stacked = "stacked";
        var mode = stacked;


        var svg = parent
            .append('svg')
            .classed('chart', true)
            .attr("width", width)
            .attr("height", height);
        var titleElement = svg.append('text')
            .classed('title', true)
            .attr('x', width / 2)
            .attr('y', titleHeight)
            .style('text-anchor', 'middle')
            .text(title);

        var chartArea = svg.append('g')
            .attr('width', width)
            .attr('height', height - titleHeight - titleMargin)
            .attr('transform', 'translate(0, ' + (titleHeight + titleMargin) + ')');

        var update = function() {
            var yScale
            if (mode == exploded) {
                yScale = d3.scale.linear()
                    .domain([0, data.map(function(d) {
                        return d3.max(d.values);
                    }).reduce(function(prev, cur) {
                        return prev + cur;
                    }, 0)])
                    .range([0, +chartArea.attr('height')]);
                var scaledData = data.map(function(d) {
                    return {
                        title: d.title,
                        values: d.values.map(function(v) {
                            return yScale(v);
                        })
                    };
                });

                var rowUpdate = chartArea.selectAll('g')
                    .data(scaledData);
                var row = rowUpdate.enter()
                    .append('g')
                    .attr('transform', function(d) {
                        var transform = 'translate(' + (width / 2) + ', ' + height + ')'
                        return transform;
                    })
                    .on('mouseover', function(d, i, a) {
                        d3.selectAll(this.childNodes)
                            .classed('active', true);
                    })
                    .on('mouseout', function(d, i, a) {
                        d3.selectAll(this.childNodes)
                            .classed('active', false);
                    });
                rowUpdate.yOffset = 0;
                rowUpdate
                    .transition()
                    .duration(500)
                    .attr('transform', function(d) {
                        rowUpdate.yOffset += d3.max(d.values) / 2
                        var transform = 'translate(' + (width / 2) + ', ' + rowUpdate.yOffset + ')'
                        rowUpdate.yOffset += d3.max(d.values) / 2;
                        return transform;
                    });
                rowUpdate.exit()
                    .transition()
                    .remove();
                var line = row
                    .append('polygon')
                    .classed('center-fill', true)
                    .attr('points', function(d) {
                        var points = [
                            [-centerSpacing, 0],
                            [centerSpacing, 0],
                            [centerSpacing, 0],
                            [-centerSpacing, 0]
                        ];
                        return points.map(function(point) {
                            return point.join(' ');
                        }).join(', ');
                    })
                rowUpdate.select('polygon')
                    .transition()
                    .duration(500)
                    .attr('points', function(d) {
                        var points = [
                            [-centerSpacing, -d.values[0] / 2],
                            [centerSpacing, -d.values[1] / 2],
                            [centerSpacing, d.values[1] / 2],
                            [-centerSpacing, d.values[0] / 2]
                        ];
                        return points.map(function(point) {
                            return point.join(' ');
                        }).join(', ');
                    });
                rowUpdate.exit().
                select('polygon')
                    .transition()
                    .attr('points', function(d) {
                        var points = [
                            [-centerSpacing, 0],
                            [centerSpacing, 0],
                            [centerSpacing, 0],
                            [-centerSpacing, 0]
                        ];
                        return points.map(function(point) {
                            return point.join(' ');
                        }).join(', ');
                    })
                    .remove();
                var boxUpdate = rowUpdate.selectAll('rect')
                    .data(function(d) {
                        return d.values;
                    });
                var box = boxUpdate.enter()
                    .append('rect')
                    .classed('box', true)
                    .classed('box-left', function(d, i) {
                        return !i;
                    })
                    .classed('box-right', function(d, i) {
                        return !!i;
                    })
                    .attr('width', boxWidth)
                    .attr('height', 0)
                    .attr('x', function(d, i, a) {
                        if (!i) {
                            // Left side
                            return -centerSpacing - boxWidth;
                        }
                        // Right side
                        return centerSpacing;
                    });
                boxUpdate
                    .transition()
                    .duration(500)
                    .attr('height', function(d) {
                        return d;
                    })
                    .attr('transform', function(d) {
                        return 'translate(0, ' + -d / 2 + ')';
                    });
                rowUpdate.exit().selectAll('g g rect')
                    .transition()
                    .attr('height', function(d) {
                        return 0;
                    })
                    .attr('transform', function(d) {
                        return 'translate(0, 0)';
                    })
                    .remove();
            } else if (mode === stacked) {
                yScale = d3.scale.linear()
                    .domain([0, d3.max(data.map(function(d) {
                        return d.values;
                    }).reduce(function(prev, cur) {
                        return [prev[0] + cur[0], prev[1] + cur[1]];
                    }, [0, 0]))])
                    .range([0, +chartArea.attr('height')]);
                var scaledData = data.map(function(d) {
                    return {
                        title: d.title,
                        values: d.values.map(function(v) {
                            return yScale(v);
                        })
                    };
                });

                var rowUpdate = chartArea.selectAll('g')
                    .data(scaledData);
                var row = rowUpdate.enter()
                    .append('g')
                    .attr('transform', function(d) {
                        var transform = 'translate(' + (width / 2) + ', 0)'
                        return transform;
                    })
                    .on('mouseover', function(d, i, a) {
                        d3.selectAll(this.childNodes)
                            .classed('active', true);
                    })
                    .on('mouseout', function(d, i, a) {
                        d3.selectAll(this.childNodes)
                            .classed('active', false);
                    });
                rowUpdate
                    .transition()
                    .duration(500)
                    .attr('transform', function(d) {
                        var transform = 'translate(' + (width / 2) + ', 0)'
                        return transform;
                    });
                rowUpdate.exit()
                    .transition()
                    .remove();
                var line = row
                    .append('polygon')
                    .classed('center-fill', true)
                    .attr('points', function(d) {
                        var points = [
                            [-centerSpacing, 0],
                            [centerSpacing, 0],
                            [centerSpacing, 0],
                            [-centerSpacing, 0]
                        ];
                        return points.map(function(point) {
                            return point.join(' ');
                        }).join(', ');
                    })
                rowUpdate.select('polygon')
                    .transition()
                    .duration(500)
                    .attr('points', function(d) {
                        var points = [
                            [-centerSpacing, -d.values[0] / 2],
                            [centerSpacing, -d.values[1] / 2],
                            [centerSpacing, d.values[1] / 2],
                            [-centerSpacing, d.values[0] / 2]
                        ];
                        return points.map(function(point) {
                            return point.join(' ');
                        }).join(', ');
                    });
                rowUpdate.exit().
                select('polygon')
                    .transition()
                    .attr('points', function(d) {
                        var points = [
                            [-centerSpacing, 0],
                            [centerSpacing, 0],
                            [centerSpacing, 0],
                            [-centerSpacing, 0]
                        ];
                        return points.map(function(point) {
                            return point.join(' ');
                        }).join(', ');
                    })
                    .remove();
                var boxUpdate = rowUpdate.selectAll('rect')
                    .data(function(d) {
                        return d.values;
                    });
                var box = boxUpdate.enter()
                    .append('rect')
                    .classed('box', true)
                    .classed('box-left', function(d, i) {
                        return !i;
                    })
                    .classed('box-right', function(d, i) {
                        return !!i;
                    })
                    .attr('width', boxWidth)
                    .attr('height', 0)
                    .attr('x', function(d, i, a) {
                        if (!i) {
                            // Left side
                            return -centerSpacing - boxWidth;
                        }
                        // Right side
                        return centerSpacing;
                    });
                boxUpdate
                    .transition()
                    .duration(500)
                    .attr('height', function(d) {
                        return d;
                    })
                    .attr('transform', function(d, i, a) {
                        console.log(scaledData.map(function(d) {
                            return d.values[i];
                        }).reduce(function(prev, curr) {
                            return prev + cur;
                        }, 0))
                        return 'translate(0, ' + scaledData.map(function(d) {
                            return d.values[i];
                        }).slice(0, a).reduce(function(prev, curr) {
                            return prev + curr;
                        }, 0) + ')';
                    });
                rowUpdate.exit().selectAll('g g rect')
                    .transition()
                    .attr('height', function(d) {
                        return 0;
                    })
                    .attr('transform', function(d) {
                        return 'translate(0, 0)';
                    })
                    .remove();
            }
        }
        var updateButton = svg.append('a')
            .attr('xlink:href', '#')
            .on('click', update)
            .attr('transform', 'translate(' + (width - 100) + ',' + 40 + ')');
        updateButton
            .append('rect')
            .attr('width', 80)
            .attr('height', 20)
            .attr('fill', 'white')
            .attr('x', -5)
            .attr('y', -15)
            .attr('rx', 5)
            .attr('ry', 5);
        updateButton
            .append('text')
            .text('button text')

        update();
    };

    d3.select('body').call(createStackedComparison);

    data.pop()
    data.pop()
    </script>
</body>

</html>
