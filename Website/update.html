<!DOCTYPE html>
<html>

<head>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
    <link rel='stylesheet' type='text/css' href='/css/force.css'>
</head>

<body>
    <script>
    function createForce() {
        // Add and remove elements on the graph object
        this.addNode = function(id, size) {
            nodes.push({
                id: id,
                size: size
            });
            update();
            return this;
        };

        this.editNode = function(id, size) {
            var i = 0;
            var n = findNode(id);
            n.size = size;
            update();
            return this;
        }

        this.removeNode = function(id) {
            var i = 0;
            var n = findNode(id);
            while (i < links.length) {
                if ((links[i]['source'] == n) || (links[i]['target'] == n)) {
                    links.splice(i, 1);
                } else i++;
            }
            nodes.splice(findNodeIndex(id), 1);
            update();
            return this;
        };

        this.removeLink = function(source, target) {
            for (var i = 0; i < links.length; i++) {
                if (links[i].source.id == source && links[i].target.id == target) {
                    links.splice(i, 1);
                    break;
                }
            }
            update();
            return this;
        };

        this.addLink = function(source, target, strength) {
            links.push({
                "source": findNode(source),
                "target": findNode(target),
                "value": strength
            });
            update();
            return this;
        };

        var findNode = function(id) {
            for (var i in nodes) {
                if (nodes[i]["id"] === id) return nodes[i];
            };
        };

        var findNodeIndex = function(id) {
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].id == id) {
                    return i;
                }
            };
        };

        var findLink = function(source, target) {
            for (var i = 0; i < links.length; i++) {
                if (links[i].source.id == source && links[i].target.id == target) {
                    return links[i]
                } else if (links[i].source.id == target && links[i].target.id == source) {
                    return links[i]
                }
            }
        }

        // set up the D3 visualisation in the specified element
        var w = 960,
            h = 450;

        var color = d3.scale.category10();

        var vis = d3.select("body")
            .append("svg:svg")
            .attr("width", w)
            .attr("height", h)
            .append('svg:g');

        var force = d3.layout.force();

        var nodes = force.nodes(),
            links = force.links();

        var update = function() {
            var linkSizes = links.map(function(l) {
                return l.value;
            });
            var smallestLink = d3.min(linkSizes);
            var largestLink = d3.max(linkSizes);
            var linkStrengthScale = d3.scale.linear()
                .domain([0, largestLink])
                .range([0, 1]);
            var strokeScale = d3.scale.pow()
                .domain([smallestLink, largestLink])
                .range([1, 10]);
            var linkDistanceScale = d3.scale.pow()
                .domain([smallestLink, largestLink])
                .range([300, 10]);

            var link = vis.selectAll("line")
                .data(links, function(d) {
                    return d.source.id + "-" + d.target.id;
                });

            link.enter().append("line")
                .attr("id", function(d) {
                    return d.source.id + "-" + d.target.id;
                })
                .attr("class", "link");
            vis.selectAll('line')
                .attr("stroke-width", function(d) {
                    return strokeScale(d.value);
                });
            link.exit().remove();

            var node = vis.selectAll("g.node")
                .data(nodes, function(d) {
                    console.log(d.id);
                    return d.id;
                });
            node.exit().remove();
            var nodeEnter = node.enter()
                .append("g")
                .classed("node", true)
                .classed('sendToTop', true)
                .call(force.drag);
            nodeEnter.append("svg:circle")
                .attr("id", function(d) {
                    return "Node;" + d.id;
                })
                .attr("fill", function(d) {
                    return color(d.id);
                });
            node.select('circle')
                .attr("r", function(d) {
                    return d.size;
                });
            nodeEnter.append('defs')
                .append('clipPath')
                .attr('id', function(d, i) {
                    return 'circle' + i;
                })
                .append('circle');
            node.select('defs>clipPath>circle')
                .attr("r", function(d) {
                    return d.size / 1.2;
                });
            nodeEnter.append('image')
                .attr('clip-path', function(d, i) {
                    return 'url(#circle' + i + ')';
                })
                .attr('xlink:href', function(d) {
                    return 'http://ddragon.leagueoflegends.com/cdn/5.2.1/img/item/' + d.id + '.png'
                });
            node.select('image')
                .attr('width', function(d) {
                    return 2 * d.size / 1.2;
                })
                .attr('height', function(d) {
                    return 2 * d.size / 1.2;
                })
                .attr('x', function() {
                    return -d3.select(this).attr('width') / 2;
                })
                .attr('y', function() {
                    return -d3.select(this).attr('height') / 2;
                });

            // because of the way the network is created, nodes are created first, and links second,
            // so the lines were on top of the nodes, this just reorders the DOM to put the svg:g on top
            $(".sendToTop").each(function(index) {
                this.parentNode.appendChild(this);
            });

            force.on("tick", function() {
                node.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

                link.attr("x1", function(d) {
                        return d.source.x;
                    })
                    .attr("y1", function(d) {
                        return d.source.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.y;
                    });
            });

            // Restart the force layout.
            force
                .gravity(.1)
                .charge(-80000)
                .friction(0.1)
                .linkDistance(function(d) {
                    return d.source.size + d.target.size + linkDistanceScale(findLink(d.source.id, d.target.id).value);
                })
                .linkStrength(function(d) {
                    return linkStrengthScale(d.value);
                })
                .size([w, h])
                .start();
        };

        // Make it all go
        update();
        return this;
    }

    var graph = createForce()
        .addNode(1001, 50)
        .addNode(3003, 25)
        .addNode(3004, 25)
        .addLink(1001, 3003, 0.1)
        .addLink(3003, 3004, 1)
        .editNode(1001, 10);
    </script>
</body>

</html>
